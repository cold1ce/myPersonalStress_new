package com.fimrc.jdcf.sensors;

import com.fimrc.jdcf.persistence.PersistenceLogger;
import com.fimrc.jdcf.persistence.container.SensorRecord;
import com.fimrc.jdcf.persistence.structure.SensorRecordStructure;

/**
 * This abstract super-class represents all physical sensors in a technical (software-engineering) perspective to handle global
 * actions for a specific sensor e.g. activation as well as the routing of the data-stream generated by the sensor to
 * the connected logger
 */
public class SensorModule {

    protected SensorController controller;
    private final SensorRecordStructure structure;
    private PersistenceLogger logger;
    private Thread loggingThread;
    private boolean active;
    private boolean activelogging;

    /**
     * Creates a new SensorModule
     *
     * @param logger    PersistenceLogger where this Sensor will logSensorRecord()
     * @param structure SensorRecordStructure which implements the structure for this Sensor
     */
    public SensorModule(PersistenceLogger logger, SensorRecordStructure structure) {
        setLogger(logger);
        this.structure = structure;
    }

    /**
     * Activates the sensor and starts the logging-process
     *
     * @return true if Sensor is activated
     */
    public boolean activateSensor() {
        activelogging = startLogging();
        active = true;
        return active;
    }

    /**
     * Deactivates the sensor and the corresponding logging-process
     *
     * @return true if Sensor is deactivated
     */
    public boolean deactivateSensor() {
        activelogging = !stopLogging();
        active = false;
        return !active;
    }

//    /**
//     * @param informationType Integer from the Information which will be generated / implemented in SensorRecordStructure
//     * @return true if Information generated successfully
//     */
//    public boolean generateInformation(int informationType) {
//        stopLogging();
//        Iterator<SensorRecord> readIterator = logger.readAllRecords(structure);
//        Iterator<SensorRecord> modifyIterator = structure.generateInformation(readIterator, informationType);
//        logger.modifyAllRecords(modifyIterator);
//        startLogging();
//        return true;
//    }

    /**
     * Forwards the logging-request to the specific logger
     *
     * @param record SensorRecord which will be logged
     */
    public void logSensorRecord(SensorRecord record) {
        if(record != null) logger.logSensorRecord(record);
    }

    /**
     * Checks whether this SensorModule is active or not
     *
     * @return true if the sensor is active
     */
    public boolean isActive() {
        return active;
    }

    /**
     * Returns the SensorRecordStructure of the SensorRecords created by this Sensor
     *
     * @return SensorRecordStructure which describes the structure of the SensorRecord to be logged
     */
    public SensorRecordStructure getStructure() {
        return structure;
    }

    /**
     * Returns the next Index of the logger to create an unique key.
     *
     * @return Key for the next SensorRecord to be logged
     */
    public long getNextIndex() {
        return logger.getNextIndex();
    }

    /**
     * Sets the logger for this module
     *
     * @param logger specific PersistenceLogger which logs all created SensorRecords
     */
    private void setLogger(PersistenceLogger logger) {
        this.logger = logger;
    }

    /**
     * Starts the logging-process of the current logger
     *
     * @return true if logging started successfully
     */
    public boolean startLogging() {
        if(!activelogging) {
            logger.startLogging();
            loggingThread = new Thread(logger);
            loggingThread.start();
            return true;
        }
        return false;
    }

    /**
     * Stops the logging-process of the current logger
     *
     * @return true if logging stopped successfully
     */
    public boolean stopLogging() {
        if(activelogging) {
            try {
                logger.stopLogging();
                if (loggingThread != null) {
                    loggingThread.join();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
                return false;
            }
            return true;
        }
        return false;
    }
}